" First we load all the modules.
" Who knows what they depend on,
" and we may want to change them later.

set nocompatible	" Must be first: use Vim defaults (much better!)

" Plugins may use the mapleader...
let mapleader = ","

filetype off
set runtimepath+=$HOME/profile-san/vim_dotdir
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
filetype plugin indent on

" Default for the plugins.
let g:EnhCommentifyTraditionalMode = 'No'
let g:EnhCommentifyFirstLineMode = 'No'
let g:EnhCommentifyBindInInsert = 'No'



set bs=2		" allow backspacing over everything in insert mode
set nobackup		" no   keep a backup file
set noswapfile   " If need to load a large file, then turn this off...
set viminfo='20,\"50	" read/write a .viminfo file, don't store more
			" than 50 lines of registers
set history=50		" keep 50 lines of command line history
set ruler		" show the cursor position all the time
set tabstop=4		" set the tab stop, duh!
set shiftwidth=4	" the autoindent stuff
set softtabstop=4
set sts=4
set expandtab		" So we get spaces.
set shiftround " Use muliple of shiftwith with <>
set pastetoggle=<F11>
set incsearch		"find as each lettel is typed.
set scrolloff=5		"Keep five lines showeng around cursor.
set nottyfast		" Seems to help displaying some files.
" Options to make long lines not wrap in the buffer, but wrap on-screen at
" word boundries.
set textwidth=0
set wrapmargin=0
set lbr
set wrap
set showmatch " Shew matching parons
" Showmatch
set sm  "Jump cursor display (not the actualy cursor) to the matching paren.
set showmode
set encoding=utf-8
set ai			" always set autoindenting on
set showcmd
set wildmenu
set wildmode=list:longest
set visualbell
set cul  "Cursorline?
set ttyfast
set backspace=indent,eol,start
set laststatus=1  " Only show status if > 2 windows.
if version > 702
    set relativenumber  " Line numbers are relative to cursor.
    set undodir=$HOME/.vimundordir
    set undofile
else
    set number " Line numbers.
endif
if version > 702
    set colorcolumn=80
endif

" Do not use modelines, would I want them?
set modelines=0

set hidden "Save the buffer, like when useing :e


" Only do this part when compiled with support for autocommands
if has("autocmd")
  " In text files, always limit the width of text to 78 characters
  " I don't want this. autocmd BufRead *.txt set tw=78
  " When editing a file, always jump to the last cursor position
  autocmd BufReadPost * if line("'\"") | exe "'\"" | endif
endif

set cindent

" Highlight all searches.
set hlsearch
" Always wrap around.
set wrapscan

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
  set background=dark
  colorscheme delek
endif

if has("autocmd")
 augroup cprog
  " Remove all cprog autocommands
  au!

  " When starting to edit a file:
  "   For C and C++ files set formatting of comments and set C-indenting on.
  "   For other files switch it off.
  "   Don't change the order, it's important that the line with * comes first.
  autocmd FileType *      set formatoptions=tcql nocindent comments&
  autocmd FileType c,cpp  set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
 augroup END

 augroup gzip
  " Remove all gzip autocommands
  au!

  " Enable editing of gzipped files
  "	  read:	set binary mode before reading the file
  "		uncompress text in buffer after reading
  "	 write:	compress file after writing
  "	append:	uncompress file, append, compress file
  autocmd BufReadPre,FileReadPre	*.gz set bin
  autocmd BufReadPost,FileReadPost	*.gz let ch_save = &ch|set ch=2
  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip
  autocmd BufReadPost,FileReadPost	*.gz set nobin
  autocmd BufReadPost,FileReadPost	*.gz let &ch = ch_save|unlet ch_save
  autocmd BufReadPost,FileReadPost	*.gz execute ":doautocmd BufReadPost " . expand("%:r")

  autocmd BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
  autocmd BufWritePost,FileWritePost	*.gz !gzip <afile>:r

  autocmd FileAppendPre			*.gz !gunzip <afile>
  autocmd FileAppendPre			*.gz !mv <afile>:r <afile>
  autocmd FileAppendPost		*.gz !mv <afile> <afile>:r
  autocmd FileAppendPost		*.gz !gzip <afile>:r
 augroup END
endif

" This makes search case insensitive when the pattern is all lowercase.
set ignorecase
set smartcase
set gdefault  " All substitutions are global

" this is for ispell, use by typing ":is"
let IspellLang = 'english'
let PersonalDict = '~/.ispell_' . IspellLang
execute 'set dictionary+=' . PersonalDict
set dictionary+=/usr/dict/words
set complete=.,w,k
set infercase



if &term=="xterm"
     set t_Co=8
     set t_Sb=^[4%dm
     set t_Sf=^[3%dm
endif
"if &term=="cygwin"
	"syntax off
"endif

" Add scala type detecting.
au BufRead,BufNewFile *.scala set filetype=scala





" These should be all the remappings

" Don't use Ex mode, use Q for formatting
map Q gq

" OK, this is weird, use ; as well as : for the same thing.
nnoremap ; :
vnoremap ; :
" What to do with ; ? (repeart the last f{char} or t.
" Same with ,
" Set at top: let mapleader = ","
" and now \ is what ; used to be (re-do last f, F, t, or T).
nnoremap \ ;
vnoremap \ ;


execute 'nnoremap <leader>i :w<CR>:!ispell -x -d ' . IspellLang . ' %<CR>:e<CR><CR>'
" This is for a spell use by typing ",as", or ",ase", or ",ash"
execute 'nnoremap <leader>as :w!<CR>:!aspell check "%"<CR>:e! "%"<CR><CR>'
execute 'nnoremap <leader>ae :w!<CR>:!aspell -e check "%"<CR>:e! "%"<CR><CR>'
execute 'nnoremap <leader>ah :w!<CR>:!aspell -H check "%"<CR>:e! "%"<CR><CR>'
execute 'nnoremap <leader>at :w!<CR>:!aspell -t check "%"<CR>:e! "%"<CR><CR>'
" Make
execute 'nnoremap <leader>m :w<CR>:!make<CR>'
" This is sdate.
execute 'nnoremap <leader>s :r!sdate<CR>kJ$'

" This is the total thing
execute 'nnoremap <leader>t yypkI.005+(<Esc>A)<Esc>!!b<CR>0f.lllDA<Space>'
" BC !
execute 'nnoremap <leader>b !!b'
" URL convert
execute 'nnoremap <leader>u !!tr-url-escapes<CR>'


" Change to use verymagic all the time
nnoremap / /\v
vnoremap / /\v
cnoremap %s/ %s/\v

" This is totally awesome - remap jj to escape in insert mode.
" You'll never type jj anyway, so it's great!
inoremap jj <Esc>

