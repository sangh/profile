#!/bin/bash



# Umask that lets the group have permissions to default files.
umask 0002




# If this shell is not interactive, do nothing below this.
if [[ $- != *i* ]]; then
    # This shell is not interactive.
    return
fi




[ -f "$HOME/.motd" ] && cat "$HOME/.motd"

# Enable colors for ls, etc.  Prefer $HOME/.dir_colors #64489
if [[ -f ~/.dir_colors ]]; then
	eval `dircolors -b ~/.dir_colors`
elif [[ -f /etc/DIR_COLORS ]]; then
	eval `dircolors -b /etc/DIR_COLORS`
fi
if ! ls --color >&/dev/null; then
	alias l='ls -CFh'
    # Makes it work on OSX
    export CLICOLOR=""
else
	alias l='ls -CFh --color'
fi
alias la='l -a'
alias ll='la -l'
alias d='du -hs `\ls -A`'
if which vim >& /dev/null; then
	EDITOR=vim
	VISUAL=vim
	export EDITOR VISUAL
	alias v='vim'
elif which vi >& /dev/null; then
	EDITOR=vi
	VISUAL=vi
	export EDITOR VISUAL
	alias v='vi'
fi
alias mv='mv -i'
alias cp='cp -i'
alias xa='xargs -I \{\} -n 1 -P 50'

if ! grep --color >&/dev/null; then
	alias grep="grep --color"
fi
alias g='grep -iE'
alias gr='grep -rinsEH'

alias ps='COLUMNS=400 ps'
alias p='ps -elf'
if cal -3 >&/dev/null; then
	alias cal='cal -3'
fi

# Path stuff.
pathmunge () {
	if ! echo ":${PATH}:" | grep ":${1}:" >&/dev/null; then
		if [ "$2" = "after" ] ; then
			PATH="$PATH:$1"
		else
			PATH="$1:$PATH"
		fi
	fi
}

# User's bin is more important than everything.
pathmunge "$HOME/bin"
# profile is after everything
pathmunge "$HOME/profile" after
# finally the local dir
pathmunge "." after

export PATH

# Check the window size after every command.
shopt -s checkwinsize

# enable bash completion in interactive shells
if [ -f /etc/bash_completion -a -z "$BASH_COMPLETION" ]; then
    . /etc/bash_completion
fi

# Clear the PROMPT_COMMAND, done before PS1.
export PROMPT_COMMAND='ret=$?;'
# Change the window title of X terminals
case $TERM in
	xterm*|rxvt|Eterm|eterm)
        # Must use \033 and not \e here.
		export PROMPT_COMMAND="$PROMPT_COMMAND"'echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\007"'
		;;
	screen)
		export PROMPT_COMMAND="$PROMPT_COMMAND"'echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\e\\"'
		;;
esac

# Set the fancy prompt, start by removing what was there.
# And move the cursor to the start: http://jonisalonen.com/2012/your-bash-prompt-needs-this/
PS1="\[\e[00;00m\]\[\e[G\]"
# Just for Debian set var with chroot you're in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot="$(cat /etc/debian_chroot) "
fi
PS1="${PS1}${debian_chroot:+($debian_chroot)}"
# Add the return code and time.
function returnCodeColor {
    if [[ $1 -eq 0 ]]; then
        echo "00m"
    else
        echo "41m"
    fi
}
PS1="${PS1}"'\[\e[00;$(returnCodeColor $ret)\]${ret}\[\e[00;00m\] \[\e[00;33m\]\D{%H:%M}\[\e[00m\] '
# Add (user and) host.
if [[ "root" == "$USER" ]]; then
    PS1="$PS1"'\[\e[01;31m\]\h '
else
    PS1="$PS1"'\[\e[01;32m\]\u@\h\[\e[00m\]:'
fi
# Working dir.
PS1="$PS1"'\[\e[01;34m\]\W\[\e[00;34m\]'
# Git branch and dirty.
function PS1GitBranchDirty {
    local br
    br=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    if [[ -z "$br" ]]; then
        echo ""
        return 0
    fi
    echo -n "[$br"
    lastGitStatusLine=$(git status 2> /dev/null | tail -n1)
    if [[ "$lastGitStatusLine" != 'nothing to commit (working directory clean)' 
        && "$lastGitStatusLine" != 'nothing to commit, working directory clean' ]]; then
        echo -n '*'
    fi
    echo "]"
} 
export PS1="$PS1"'$(PS1GitBranchDirty)\$\[\e[00m\] '

# HISTORY things
shopt -s histappend
export HISTIGNORE="&:[ ]*:bg:fg:exit"
export HISTFILESIZE=999999
export HISTSIZE=999999

# When do you _not_ want extended globbing?
shopt -s extglob


# Aliases to do the recursive svn add/remove.
alias svn-addremove="svn st | grep '^\?' | awk '{print \$2}' | xargs svn add && svn st | grep '^\!' | awk '{print \$2}' | xargs svn rm"

# Less is broken: http://seclists.org/fulldisclosure/2014/Nov/74
export LESS=FRX
unset LESSOPEN
unset LESSCLOSE


# This is what I use to change directories (dirs).
# If given no arguments (args) change dir to `$HOME`.
# If one arg is given and it exists, change dir to it, or if the arg is `-`
# change dir to `$OLDPWD` (the same as the regular `cd`).
# This does not use `$CDPATH` instead it is always `$PWD:$HOME`.
# Otherwise (the one argument doesn't exist or there is more than 1 argument
# then if there is a '/' in any argument, print an error, if not then go
# through each one in order and append to the path-to-change-to the directory,
# the directory or a directory that has the argument as a sub-string (if there
# are more than one match, print an error), and if none, then check the
# sub-directories for it, then continue with the rest of the arguments.
# If no matches are found, try again from $HOME.
# Will always follow symlinks.

alias ..='cd ..'
c_error_str=""
c_found_dir=""
c_glob_one_level_deep() {
    c_error_str="No matches found for \"$2\" in \"$1\"."
    c_found_dir=""
    while IFS= read -r -d $'\0' dir; do
        if [[ -z "$c_found_dir" ]]; then
            c_error_str=""
            c_found_dir=$dir
        else
            c_error_str="Multiple matches found for \"$2\" in \"$1\"."
            return
        fi
    done < <(find -L "$1" -maxdepth 1 -iname '*'"$2"'*' -and -type d -print0)
}
c() {
    if [[ $# -eq 0 ]]; then
        cd "$HOME"
        return 0
    elif [[ $# -eq 1 ]]; then
        if [[ -d "$1" ]]; then
            cd "$1"
            return
        elif [[ -d "${HOME}/$1" ]]; then  # In case '.' is not in the path
            echo "${HOME}/$1"
            cd "${HOME}/$1"
            return
        elif [[ "-" == "$1" ]]; then
            echo "$OLDPWD"
            cd "$OLDPWD"
            return
        fi
    fi
    chp=$PWD
    for arg; do
        if [[ $arg == *"/"* ]]; then
            echo "Argument \"$arg\" contains a slash, so won't glob." >&2
            return
        fi
        c_glob_one_level_deep "$chp" "$arg"
        if [[ -z "$c_error_str" ]]; then
            chp=$c_found_dir
        else
            break
        fi
    done
    if [[ -z "$c_error_str" ]]; then
        echo "$chp"
        cd "$chp"
        return
    elif [[ "$PWD" != "$HOME" ]]; then
        c_error_str_old=$c_error_str
        chp=$HOME
        for arg; do
            # Don't need the '/' check as it was done above.
            c_glob_one_level_deep "$chp" "$arg"
            if [[ -z "$c_error_str" ]]; then
                chp=$c_found_dir
            else
                break
            fi
        done
        if [[ -z "$c_error_str" ]]; then
            echo "$chp"
            cd "$chp"
            return
        fi
        echo "$c_error_str_old" >&2
    fi
    echo "$c_error_str" >&2
    return 1
}
