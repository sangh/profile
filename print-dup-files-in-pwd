#!/bin/sh
exec scala -deprecation "$0" "$@"
!#

import scala.collection.mutable.LinkedList
import java.io.File
import java.io.FileNotFoundException
import java.io.FileInputStream
import java.io.IOException


/*
    Has a series of test each can tell if the files are different, but not
    if they are the same (except the last one).  So if the sizes are different
    then they are different, but if they are the same, the files could still
    be different.
*/
class FileAttr(val name: String) extends File(name) {

    if( ! this.exists() )
        throw new FileNotFoundException(name)

    val path: String = this.getAbsolutePath()

    // First test
    val size: Long = this.length()

    // 2nd test
    lazy val firstBit: List[Byte] = {
        var ret = List[Byte]()
        val fis = new FileInputStream( this )
        val sz: Int = if( 500 < this.size ) 500 else this.size.asInstanceOf[Int]
        for( i <- 1 to sz )
            ret = ( fis.read() - 127 ).asInstanceOf[Byte] :: ret
        fis.close()
        ret.reverse
    }

    // 3rd test
    lazy val md5: String = {
        val fis = new FileInputStream( this )
        val di = java.security.MessageDigest.getInstance("MD5")
        di.reset()
        val bb = new Array[Byte](1000)
        def upd(): Unit = {
            val i = fis.read(bb)
            if( i <= 0 ) return
            di.update(bb, 0, i)
            upd()
        }
        upd()
        fis.close()
        di.digest().toList.map(0xFF & _).map { "%02x".format(_) }.foldLeft(""){_ + _}
        //List.fromArray( di.digest() ).map(0xFF & _).map { "%02x".format(_) }.foldLeft(""){_ + _}
    }

    // 4th (and final test)
    private def sameAsCharForCharHelper(    a: FileInputStream,
                                            b: FileInputStream
                                        ): Boolean = {
        while( true ) {
            val ai = a.read()
            if( b.read() != ai ) {
                return false
            }
            if( -1 == ai ) return true
        }
        throw new IOException("Don't know, should not happen.")
    }
    def sameAsCharForChar( other: FileAttr ): Boolean = {
        val thisStream = new FileInputStream( this )
        val otherStream= new FileInputStream( other )
        val ret = this.sameAsCharForCharHelper( thisStream, otherStream )
        thisStream.close()
        otherStream.close()
        ret
    }



    def toStringAllInfo(): String = "%s\n%d: %s\n%s\n%s" format (
        this.name, this.size, this.path, this.firstBit, this.md5 )

    override def toString(): String = "FileAttr(" + name + ")"

    override def equals( other: Any ): Boolean = {
        if( other.isInstanceOf[FileAttr] ) {
            val that: FileAttr = other.asInstanceOf[FileAttr]
            return ( true
                && this.size == that.size
                && this.firstBit == that.firstBit
                && this.md5 == that.md5
                && this.sameAsCharForChar( that )
            )
        } else {
            return false
        }
    }

}



def getDeepAbsNames( name: String ): LinkedList[FileAttr] = {
    val pwd = new FileAttr( name )
    if( ! pwd.isDirectory )
        throw new IOException("Cannot use getDeepAbsNames on not a dir.")
    // What null could be...
    var ret: LinkedList[FileAttr] = LinkedList()
    val filesInPwd: Array[String] = pwd.list()
    // If no files in the dir, return the blank linked list
    if( null == filesInPwd ) return ret

    for( fname <- filesInPwd ) {
        val f = new FileAttr( pwd.path + File.separator + fname )
        if( f.isFile() ) {
            val tmpll = LinkedList( f )
            tmpll.next = ret
            ret = tmpll
        } else if( f.isDirectory() ) {
            val elems = getDeepAbsNames( f.path )
            if( ! elems.isEmpty ) {
                var nx = elems
                while( ! nx.next.isEmpty ) nx = nx.next
                nx.next = ret
                ret = elems
            }
        } else {
            throw new IOException("Not a file or dir? " + f.path)
        }
    }
    ret
}





var bigPointer = getDeepAbsNames(".")

// bigPointer now has all the files in the current dir (and below).
// It points to the first file.

if( false ) {
    var i = bigPointer
    while( ! i.isEmpty ) {
        println( i.elem )
        i = i.next
    }
    java.lang.System.exit(0)
}


// big outter loop
while( ! bigPointer.isEmpty ) {

    var i = bigPointer.next
    var ilst: List[FileAttr] = List()
    while( ! i.isEmpty ) {
        if( i.elem == bigPointer.elem )
            ilst = i.elem :: ilst
        i = i.next
    }
    if( ! ilst.isEmpty ) {
        println("-------------------------")
        println( bigPointer.elem )
        ilst.reverse.map( e => println(e) )
        println("-------------------------")
    }

    bigPointer = bigPointer.next

}
